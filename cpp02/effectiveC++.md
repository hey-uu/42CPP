## 10: 대입 연산자는 *this이 참조자를 반환하게 하자

C++의 대입 연산은 여러 개를 사슬처럼 엮을 수 있고 우측 연관(right-associative) 성질을 가진다.

```c++
int x, y, z;

x = y = z = 100; // 사슬처럼 엮기
x = (y = (z = 15));
```

이를 가능하게 하기 위해서 대입 연산자는 좌변 인자에 대한 참조자를 반환하도록 구현하는 것이 **관례**이다.
이는 단순 대입형 연산자뿐만 아니라 모든 형태의 대입 연산자(+=, -=, *= 등)에서도 지켜져야 한다.

여기서 **관례**란 따르지 않고 코드를 작성하더라도 컴파일이 안됨을 의미하는 것은 아니다.
하지만 이 관례를 모든 기본제공 타입들이 따르고 있을 뿐만 아니라 표준 라이브러리에 속한 모든 타입(string, vector, complex, tr1::shared_ptr 등)에서 따르기 때문에 무시하지 못한다는 점이다.


## 11: operator=에서 자기대입에 대한 처리가 빠지지 않도록 하자

자기 대입(self-assignment)란, 어떤 객체가 자기 자신에 대해 대입 연산자를 적용하는 것을 말한다.

```c++
class Widget {...};

Widget w;
...
w = w;
```

1. 일치성 검사(identity test)
   조건문으로 동일한 주소를 가지는지 검사하기
2. 문장의 실행 순서 수작업으로 조정하기

```c++
Bitmap *pOrig = pb;
pb = new Bitmap(*rhs.pb);
delete pOrig;
```
1번이 효율이 더 좋아 보일 수 있지만 실제로 자기 대입이 자주 일어나는 일은 아니기 때문에 오히려 효율 측면에서 떨어질 수 있다.
일치성 검사 코드가 들어가게 되면 그만큼 코다가 커지고, 처리 흐름에 분기를 만들기 때문에 실행 시간 속력이 덜컥덜컥 줄어들 수 있기 때문이다. CPU 명령어 선행일출(instruction prefetch), 캐시, 파이프라이닝 등의 효과가 떨어질 수도 있고 말이다!

3. 복사 후 맞바꾸기(copy and swap) => 자주 쓰이는 방법
```c++
Widget temp(rhs);
swap(temp);
```


2.25 = 1 * 2^1 + 1 * 1^(-2)

2.25 * 2^8 = 1 * 2^9 + 1 * 2^6 
고정소수점 => 00000000 00000000 00000010 01000000
-2.25
고정소수점  => 11111111 11111111 11111101 10111111 + 1
            => 11111111 11111111 11111101 11000000

오른쪽으로 shift 연산

11111111 11111111 11111111 111111101

11111111 11111111 11111111 11111100

00000000 00000000 00000000 00000011


